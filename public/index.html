<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shared Drag Board</title>
  <script src="https://ba-exercise.onrender.com/socket.io/socket.io.js"></script>
  <style>
    html,body{height:100%;margin:0;}
    body{background:#0b1220;color:white;font-family:Inter, sans-serif;}
    .stage{position:relative;width:100vw;height:100vh;overflow:hidden;background-size:cover;background-position:center;}
    .toolbar{position:absolute;top:10px;left:10px;z-index:1000;background:rgba(0,0,0,0.3);padding:8px;border-radius:8px;display:flex;gap:8px;}
    .btn{cursor:pointer;padding:6px 10px;background:#334155;border-radius:6px;}
    input[type=file]{display:none}
    .draggable{position:absolute;cursor:grab;border-radius:6px;max-width:300px;user-select:none;}
    .draggable:active{cursor:grabbing}
    .selected{outline:3px solid #fff3}
  </style>
</head>
<body data-socket-url="https://ba-exercise.onrender.com">
<div class="stage" id="stage">
  <img id="bgImage" src="" alt="" style="width:100%; height:auto; display:block; pointer-events:none;">
</div>
<div class="toolbar">
  <label class="btn">Add images<input id="addImageInput" type="file" accept="image/*" multiple></label>
  <label class="btn">Background<input id="bgInput" type="file" accept="image/*"></label>
  <div class="btn" id="clearBtn">Clear</div>
</div>

<script src="https://ba-exercise.onrender.com/socket.io/socket.io.js"></script>
<script>
const socketUrl = document.body.dataset.socketUrl;
const socket = io(socketUrl);

const stage = document.getElementById('stage');
const bgImage = document.getElementById('bgImage');
const addImageInput = document.getElementById('addImageInput');
const bgInput = document.getElementById('bgInput');
const clearBtn = document.getElementById('clearBtn');

let selected = null;
let bgNaturalWidth = 0;
let bgNaturalHeight = 0;

// ---------------- Utilities ----------------
function createImageElement(data){
  if(stage.querySelector(`[data-id='${data.id}']`)) return;
  const img = document.createElement('img');
  img.src = data.src;
  img.dataset.id = data.id;
  img.className = 'draggable';
  img.dataset.locked = data.locked;
  img.dataset.left = data.left;
  img.dataset.top = data.top;
  img.dataset.width = data.width;

  attachHandlers(img);
  stage.appendChild(img);

  function position(){
    if(!bgNaturalWidth || !bgNaturalHeight) return;
    const rect = bgImage.getBoundingClientRect();
    img.style.left = (parseFloat(img.dataset.left) * rect.width) + 'px';
    img.style.top = (parseFloat(img.dataset.top) * rect.height) + 'px';
    img.style.width = (parseFloat(img.dataset.width) * rect.width) + 'px';
  }

  // Call once when bg loads or window resizes
  bgImage.addEventListener('load', position);
  window.addEventListener('resize', position);
  position();
}

function attachHandlers(img){
  img.addEventListener('pointerdown', startDrag);
  img.addEventListener('click', e => { e.stopPropagation(); select(img); });
}

function select(img){
  if(selected) selected.classList.remove('selected');
  selected = img;
  if(img) img.classList.add('selected');
}

// ---------------- Drag logic ----------------
stage.addEventListener('click', ()=> select(null));

function startDrag(e){
  if(e.button !== 0) return;
  const img = e.target;
  img.setPointerCapture(e.pointerId);

  const rect = bgImage.getBoundingClientRect();
  const origLeft = parseFloat(img.style.left);
  const origTop = parseFloat(img.style.top);
  const startX = e.clientX;
  const startY = e.clientY;

  function move(ev){
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;
    img.style.left = (origLeft + dx) + 'px';
    img.style.top = (origTop + dy) + 'px';
  }

  function end(ev){
    const rect = bgImage.getBoundingClientRect();
    const leftFrac = parseFloat(img.style.left) / rect.width;
    const topFrac = parseFloat(img.style.top) / rect.height;

    // Update local dataset
    img.dataset.left = leftFrac;
    img.dataset.top = topFrac;

    socket.emit('move_image', { id: img.dataset.id, left: leftFrac, top: topFrac });
    img.releasePointerCapture(ev.pointerId);
    img.removeEventListener('pointermove', move);
    img.removeEventListener('pointerup', end);
  }

  img.addEventListener('pointermove', move);
  img.addEventListener('pointerup', end);
}

// ---------------- Add images ----------------
addImageInput.addEventListener('change', e =>{
  const files = [...e.target.files];
  if(files.length === 0 || !bgNaturalWidth || !bgNaturalHeight) return;

  const rect = bgImage.getBoundingClientRect();
  const promises = files.map((file, i) => new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = () => {
      const id = 'img_' + Math.random().toString(36).slice(2);
      const cols = Math.ceil(Math.sqrt(files.length));
      const gap = 20;
      const cellW = 100;
      const cellH = 100;
      const r = Math.floor(i / cols);
      const c = i % cols;
      const leftPx = c * (cellW + gap) + 20;
      const topPx = r * (cellH + gap) + 20;
      const left = leftPx / rect.width;
      const top = topPx / rect.height;
      const width = 100 / rect.width;
      const data = { id, src: reader.result, left, top, width, locked: false };
      createImageElement(data);
      resolve(data);
    };
    reader.readAsDataURL(file);
  }));

  Promise.all(promises).then(imgs => {
    socket.emit('add_images', imgs);
  });
});

// ---------------- Background ----------------
bgInput.addEventListener('change', e =>{
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    bgImage.src = reader.result;
    socket.emit('set_background', reader.result);
  };
  reader.readAsDataURL(file);
});

// Update natural size when background loads
bgImage.addEventListener('load', ()=>{
  bgNaturalWidth = bgImage.naturalWidth;
  bgNaturalHeight = bgImage.naturalHeight;
});

// ---------------- Clear ----------------
clearBtn.addEventListener('click', ()=>{
  stage.querySelectorAll('.draggable').forEach(i=>i.remove());
  bgImage.src = '';
  socket.emit('clear_all');
});

// ---------------- Socket handlers ----------------
socket.on('initial_state', layout =>{
  if(layout.background) bgImage.src = layout.background;
  layout.items.forEach(data => createImageElement(data));
});

socket.on('images_added', imgs =>{
  imgs.forEach(data => createImageElement(data));
});

socket.on('image_moved', data =>{
  const img = stage.querySelector(`[data-id='${data.id}']`);
  if(img && bgNaturalWidth && bgNaturalHeight){
    const rect = bgImage.getBoundingClientRect();
    img.dataset.left = data.left;
    img.dataset.top = data.top;
    img.style.left = (data.left * rect.width) + 'px';
    img.style.top = (data.top * rect.height) + 'px';
  }
});

socket.on('background_set', dataUrl =>{
  bgImage.src = dataUrl;
});

socket.on('all_cleared', ()=>{
  stage.querySelectorAll('.draggable').forEach(i=>i.remove());
  bgImage.src = '';
});
</script>
